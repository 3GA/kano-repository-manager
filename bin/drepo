#!/usr/bin/env ruby

# Notes:

# drepo build [pkg-name] [-f]
#       build [pkg-name] --scratch [topic-branch]
#
#   - The old script basically
#   - Change versions to date stamps
#   - Add support for scratch suite builds

# drepo release [pkg-name]
#       release [pkg-name] --scratch
#
#   - Move the current devel package to release
#   - Or alternatively move the current devel package

# drepo remove [pkg-or-deb-name]
#
#   - Remove a single deb
#   - Remove all the packages related to a git package

# drepo rebuild-all [-f]
#
#   - Just rebuild all the packages

# drepo release-all
#
#   - Push all the packages from devel to release

# make sure locking works properly

require "thor"
require "fileutils"
require "io/console"

require "mkpkg/repo"

class RepoCLI < Thor
  class_option :repo, :type => :string
  #Â drepo init [location]
  #   - Setup a new repository
  #   - Not a highest priority
  #
  #   - Create the repo config
  #   - Use reprepro to initialize files
  #   - Generate signing key
  desc "init [LOCATION]", "setup a whole new repository from scratch"
  def init(location=".")
    say "Initialising a debian repository at '#{location}'"

    FileUtils.mkdir_p location

    repo_conf = {
      :name => "Debian Repository",
      :desc => "",
      :arches => ["amd64"],
      :components => ["main"],
      :suites => ["stable", "testing", "unstable"],
      :codenames => []
    }

    name = ask "Repository name [#{repo_conf[:name]}]:"
    repo_conf[:name] = name if name.length > 0

    desc = ask "Description [#{repo_conf[:desc]}]"
    repo_conf[:desc] = desc if desc.length > 0

    arches = ask "Architectures [#{repo_conf[:arches].join " "}]:"
    repo_conf[:arches] = arches.split /\s+/ if arches.length > 0

    components = ask "Components [#{repo_conf[:components].join " "}]:"
    repo_conf[:components] = components.split /\s+/ if components.length > 0

    repo_conf[:gpg_name] = ask "Cert owner name (required):"
    repo_conf[:gpg_mail] = ask "Cert owner e-mail (required):"

    print "Passphrase (optional): "
    repo_conf[:gpg_pass] = STDIN.noecho(&:gets).chomp
    print "\n"

    suites = ask "Suites [#{repo_conf[:suites].join " "}]:"
    repo_conf[:suites] = suites.split /\s+/ if suites.length > 0

    repo_conf[:suites].each do |s|
      codename = ask "Codename for '#{s}':"
      repo_conf[:codenames].push codename
    end

    r = Mkpkg::Repo.new location
    r.setup repo_conf
  end

  # drepo add [-o] --git [addr] --branch [devel-branch]
  #       add [-o] --deb [path] --name [pkg-name]
  #
  #   - Rip off the old add script
  #   - Add special handling for deb files alone
  #   - -o override package or source
  desc "add", "introduce a new package to the build system"
  method_option :git, :aliases => "-g", :desc => "Add source package managed in a git repo"
  method_option :deb, :aliases => "-d", :desc => "Add a prebuilt binary deb package only"
  method_option :override, :aliases => "-o", :desc => "Proceed even if the package already exists"
  method_option :branch, :aliases => "-b", :desc => "Use a specific branch (valid only with --git)"
  method_option :suite, :aliases => "-s", :desc => "Specify target suite", :required => true
  method_option :component, :aliases => "-c", :desc => "Specify target component (defaults to main)"
  def add
    if options.has_key? :repo
      repo = Mkpkg::Repo.new options[:repo]
    else
      # TODO: Get it from the configuration file in the future
      raise ArgumentError, "--repo option missing"
    end

    case
    when options.has_key?(:git)
      branch = "main"
      branch = options[:branch] if options.has_key? :branch

      repo.add_git_pkg options[:git], branch
    when options.has_key?(:deb)
      repo.add_deb_pkg options[:git]
    else
      raise ArgumentError, "Either --git or --deb must be specified"
    end
  end

  #def build()
  #end

  #def release()
  #end

  #def remove()
  #end

  #def rebuild_all()
  #end

  #def release_all()
  #end
end

RepoCLI.start ARGV
