#!/usr/bin/env ruby

# Notes:

# drepo release [pkg-name]
#       release [pkg-name] --scratch
#
#   - Move the current devel package to release
#   - Or alternatively move the current devel package

# drepo remove [pkg-or-deb-name]
#
#   - Remove a single deb
#   - Remove all the packages related to a git package

# drepo rebuild-all [-f]
#
#   - Just rebuild all the packages

# drepo release-all
#
#   - Push all the packages from devel to release

# make sure locking works properly

require "thor"
require "fileutils"
require "io/console"

require "mkpkg/repo"
require "mkpkg/gitpackage"
require "mkpkg/debpackage"

class List < Thor
  desc "packages", "show a list of source packages in the repo"
  def packages()
    if options.has_key? "repo"
      repo = Mkpkg::Repo.new options["repo"]
    else
      repo = Mkpkg::Repo.new Dir.pwd
    end

    repo.list_packages.each do |pkg|
      puts pkg.name
    end
  end

  desc "versions PACKAGE", "show a history of all available package versions"
  def versions(pkg_name)
    if options.has_key? "repo"
      repo = Mkpkg::Repo.new options["repo"]
    else
      repo = Mkpkg::Repo.new Dir.pwd
    end

    suites = repo.get_suites

    pkg = repo.get_package pkg_name
    pkg.history.each do |version|
      line = "#{version}"
      suites.each do |suite, codename|
        codename = suite if codename == nil
        if repo.query_for_version(suite, pkg.name) == version
          line << " [#{codename}]"
        end
      end
      puts line
    end
  end
end

class RepoCLI < Thor
  class_option :repo, :type => :string
  #Â drepo init [location]
  #   - Setup a new repository
  #   - Not a highest priority
  #
  #   - Create the repo config
  #   - Use reprepro to initialize files
  #   - Generate signing key
  desc "init [LOCATION]", "setup a whole new repository from scratch"
  def init(location=".")
    say "Initialising a debian repository at '#{location}'"

    FileUtils.mkdir_p location

    repo_conf = {
      :name => "Debian Repository",
      :desc => "",
      :arches => ["amd64"],
      :components => ["main"],
      :suites => ["stable", "testing", "unstable"],
      :codenames => []
    }

    name = ask "Repository name [#{repo_conf[:name]}]:"
    repo_conf[:name] = name if name.length > 0

    desc = ask "Description [#{repo_conf[:desc]}]"
    repo_conf[:desc] = desc if desc.length > 0

    arches = ask "Architectures [#{repo_conf[:arches].join " "}]:"
    repo_conf[:arches] = arches.split /\s+/ if arches.length > 0

    components = ask "Components [#{repo_conf[:components].join " "}]:"
    repo_conf[:components] = components.split /\s+/ if components.length > 0

    repo_conf[:gpg_name] = ask "Cert owner name (required):"
    repo_conf[:gpg_mail] = ask "Cert owner e-mail (required):"

    print "Passphrase (optional): "
    repo_conf[:gpg_pass] = STDIN.noecho(&:gets).chomp
    print "\n"

    # Don't ask for suites (we need three anyway)
    #suites = ask "Suites [#{repo_conf[:suites].join " "}]:"
    #repo_conf[:suites] = suites.split /\s+/ if suites.length > 0

    repo_conf[:suites].each do |s|
      codename = ask "Codename for '#{s}':"
      repo_conf[:codenames].push codename
    end

    r = Mkpkg::Repo.new location
    r.setup repo_conf
  end

  # drepo add [-o] --git [addr] --branch [devel-branch]
  #       add [-o] --deb [path] --name [pkg-name]
  #
  #   - Rip off the old add script
  #   - Add special handling for deb files alone
  #   - -o override package or source
  desc "add", "introduce a new package to the build system"
  method_option :git, :aliases => "-g", :desc => "Add source package managed in a git repo"
  method_option :deb, :aliases => "-d", :desc => "Add a prebuilt binary deb package only"
  method_option :force, :aliases => "-f", :desc => "Proceed even if the package already exists"
  method_option :branch, :aliases => "-b", :desc => "Set a default branch other than master (valid only with --git)"
  def add
    repo = get_repo_handle

    case
    when options.has_key?("git")
      branch = "master"
      branch = options["branch"] if options.has_key? "branch"

      Mkpkg::GitPackage::setup repo, options["git"], branch
    when options.has_key?("deb")
      Mkpkg::DebPackage::setup repo, options["deb"]
    else
      raise ArgumentError, "Either --git or --deb must be specified"
    end
  end

  # drepo build [pkg-name] --branch [topic-branch]
  # drepo build [pkg-name] --branch [topic-branch] --push [suite] -f
  #
  #   - The old script basically
  #   - Change versions to date stamps
  #   - Add support for scratch suite builds
  desc "build [pkg-name]", "build a package from the sources"
  method_option :branch, :aliases => "-b", :type => :string,
                :desc => "build from a different branch"
  method_option :push, :aliases => "-p", :type => :string,
                :desc => "push to suite immediately after building"
  method_option :force, :aliases => "-f", :type => :boolean,
                :desc => "force build even when no changes have been made"
  def build(pkg_name)
    repo = get_repo_handle

    force = false
    force = options["force"] if options.has_key? "force"

    branch = nil
    branch = options["branch"] if options.has_key? "branch"

    pkg = repo.get_package pkg_name
    version = pkg.build branch, force

    if options["push"] && version
      if options["push"] == "push"
        repo.push pkg.name, version, "testing" # FIXME: should be configurable
      else
        repo.push pkg.name, version, options["push"]
      end
    end
  end

  # drepo push [pkg-name] -f --suite X --version Y
  desc "push [pkg-name]", "push a built package to a specified suite"
  method_option :suite, :aliases => "-s", :type => :string,
                :desc => "the target suite (defaults to testing)"
  method_option :version, :aliases => "-v", :type => :string,
                :desc => "which version to push (defaults to the highest one build)"
  method_option :force, :aliases => "-f", :type => :boolean,
                :desc => "force inclusion of the package to the suite"
  def push(pkg_name)
    repo = get_repo_handle

    suite = nil
    suite = options["suite"] if options.has_key? "suite"

    version = nil
    version = options["version"] if options.has_key? "version"

    repo.push pkg_name, version, suite, options["force"] == true
  end

  desc "unpush [pkg-name] [suite]", "remove a built package from a suite"
  def unpush(pkg_name, suite)
    repo = get_repo_handle
    repo.unpush pkg_name, suite
  end

  desc "list SUBCOMMAND [ARGS]", "show information about packages"
  subcommand "list", List

  desc "remove [pkg-name]", "remove a package completely from the build system"
  method_option :force, :aliases => "-f", :type => :boolean,
                :desc => "force removal even if the package is still used"
  def remove(pkg_name)
    repo = get_repo_handle
    repo.remove pkg_name, options["force"] == true
  end

  private
  def get_repo_handle
    if options.has_key? "repo"
      Mkpkg::Repo.new options["repo"]
    else
      Mkpkg::Repo.new Dir.pwd
    end
  end
end

RepoCLI.start ARGV
