#!/usr/bin/env ruby

# Copyright (C) 2014 Kano Computing Ltd.
# License: http://www.gnu.org/licenses/gpl-2.0.txt GNU General Public License v2

require "thor"
require "fileutils"
require "io/console"

require "dr"
require "dr/repo"
require "dr/gitpackage"
require "dr/debpackage"
require "dr/buildroot"

require "dr/shellcmd"
require "dr/logger"
require "dr/config"


class ExtendedThor < Thor
  private
  include Dr::Logger

  def get_repo_handle
    if options.has_key? "repo"
      Dr::Repo.new options["repo"]
    else
      if Dr.config.default_repo != nil
        Dr::Repo.new Dr.config.repositories[Dr.config.default_repo][:location]
      else
        log :warn, "No repo was specified, using '#{Dir.pwd}'."
        Dr::Repo.new Dir.pwd
      end
    end
  end
end


class Archive < ExtendedThor
  #desc "save TAG", "make a snapshot of the current archive"
  #def save(tag)
  #end

  #desc "restore TAG", "replace the current archive with an earlier snapshot"
  #def restore(tag)
  #end

  #desc "list-versions", "show all snapshots"
  #map  "list-versions" => :list_versions
  #def list_versions
  #end
end


class List < ExtendedThor
  desc "packages", "Show a list of source packages in the repo"
  def packages()
    repo = get_repo_handle
    log :info, "Listing all source packages in the repository"

    repo.list_packages.each do |pkg|
      log :info, "  #{pkg.name.fg "orange"}"
    end
  end


  desc "versions PACKAGE", "Show the history of all available versions for a package"
  def versions(pkg_name)
    repo = get_repo_handle
    log :info, "Listing all built versions of #{pkg_name.style "pkg-name"}"

    suites = repo.get_suites

    pkg = repo.get_package pkg_name
    pkg.history.each do |version|
      line = "#{version.style "version"}"

      if pkg.build_exists? version
        debs = repo.get_build pkg.name, version

        metadata = repo.get_build_metadata pkg.name, version
        if metadata.has_key? "branch"
          open = "{".fg "dark-grey"
          close = "}".fg "dark-grey"
          line << " " + open + metadata["branch"].fg("blue") + close
        end

        subpkgs = debs.map { |p| File.basename(p).split("_")[0] }
      end

      open = "[".fg "dark-grey"
      close = "]".fg "dark-grey"

      if subpkgs.length == 0
        line << " " + open + "broken".fg("red") + close
      else
        suites.each do |suite, codename|
          codename = suite if codename == nil

          colour = case suite
          when "stable" then "red"
          when "testing" then "yellow"
          when "unstable" then "green"
          else nil end

            all_included = true
            subpkgs.each do |subpkg|
              unless repo.query_for_deb_version(suite, subpkg) == version
                all_included = false
              end
            end

            if all_included
              if colour
                line << " " + open + codename.fg(colour) + close
              else
                line << " " + open + codename + close
              end
            end
        end
      end
      log :info, "  #{line}"
    end
  end


  desc "suite SUITE", "Show the names and versions of packages in the suite"
  def suite(suite)
    repo = get_repo_handle

    suites = repo.get_suites
    exists = suites.inject(false) { |r, s| r || s.include?(suite) }
    raise "Suite '#{suite}' doesn't exist" unless exists

    log :info, "Listing all the packages in #{suite.fg "blue"}"

    suite = repo.codename_to_suite suite
    suite_packages = repo.list_packages
    suite_packages.each do |pkg|
      versions = repo.get_subpackage_versions pkg.name
      unless versions[suite].empty?
        if versions[suite].length == 1 && versions[suite].has_key?(pkg.name)
          log :info, "  #{pkg.name.style "pkg-name"}  " +
                     "#{versions[suite][pkg.name].style "version"}"
        else
          log :info, "  #{pkg.name.style "pkg-name"}"
          versions[suite].each do |subpkg, version|
            log :info, "    #{subpkg.style "subpkg-name"}  " +
                       "#{version.style "version"}"
          end
        end
      end
    end
  end
end


class RepoCLI < ExtendedThor
  class_option :repo, :type => :string, :aliases => "-r"


  desc "init [LOCATION]", "setup a whole new repository from scratch"
  def init(location=".")
    log :info, "Initialising a debian repository at '#{location.fg("blue")}'"

    repo_conf = {
      :name => "Debian Repository",
      :desc => "",
      :arches => ["amd64"],
      :components => ["main"],
      :suites => ["stable", "testing", "unstable"],
      :distro => "Kano OS",
      :codenames => []
    }

    name = ask "   Repository name "<< "[#{repo_conf[:name].fg("yellow")}]:"
    repo_conf[:name] = name if name.length > 0

    desc = ask "   Description [#{repo_conf[:desc]}]:"
    repo_conf[:desc] = desc if desc.length > 0

    distro_map = {}
    puts "   Distribution [pick one]: "
    Dr::config.distros.each_with_index do |distro, index|
      distro_name = distro[0]
      distro_map[index+1] = distro_name

      distro_name = distro_name.fg "yellow" if distro_name == repo_conf[:distro]
      puts "     [#{index+1}] #{distro_name}"
    end

    distro = ask "   Your choice: "
    until distro.length == 0 || distro_map.has_key?(distro.to_i)
      distro = ask "   Your choice: "
    end
    repo_conf[:distro] = distro_map[distro.to_i] if distro.length > 0

    require 'pp'
    # guess default arch
    pp Dr::config.distros
    pp Dr::config.distros[repo_conf[:distro]]
    repo_conf[:arches] = [Dr::config.distros[repo_conf[:distro]][:arches][0]]

    while true
      str = ask "   Architectures [#{repo_conf[:arches].join(" ").fg("yellow")}]:"
      break if str.length == 0

      arches = str.split(/\s+/)
      arches_valid = arches.reduce(true) do |acc, arch|
        supported = Dr::config.distros[repo_conf[:distro]][:arches].include?(arch)
        if !supported
          puts "     " + "#{arch.fg "yellow"}" + " not supported by the distro"
        end

        supported
      end
      next if !arches_valid

      repo_conf[:arches] = arches
      break
    end

    components = ask "   Components [#{repo_conf[:components].join(" ").fg("yellow")}]:"
    repo_conf[:components] = components.split(/\s+/) if components.length > 0

    repo_conf[:gpg_name] = ""
    while repo_conf[:gpg_name].length == 0
      repo_conf[:gpg_name] = ask "   Cert owner name (#{"required".fg("red")}):"
      repo_conf[:gpg_name].strip!
    end

    repo_conf[:gpg_mail] = ""
    while repo_conf[:gpg_mail].length == 0
      repo_conf[:gpg_mail] = ask "   Cert owner e-mail (#{"required".fg("red")}):"
      repo_conf[:gpg_mail].strip!
    end

    print "   Passphrase (#{"optional".fg("green")}): "
    repo_conf[:gpg_pass] = STDIN.noecho(&:gets).chomp
    print "\n"

    repo_conf[:suites].each do |s|
      codename = ask "   Codename for '#{s.fg("yellow")}':"
      repo_conf[:codenames].push codename
    end

    r = Dr::Repo.new location
    r.setup repo_conf
  end


  desc "add", "introduce a new package to the build system"
  method_option :git, :aliases => "-g",
    :desc => "Add source package managed in a git repo"
  method_option :deb, :aliases => "-d",
    :desc => "Add a prebuilt binary deb package only"
  method_option :force, :aliases => "-f", :type => :boolean,
    :desc => "Proceed even if the package already exists"
  method_option :branch, :aliases => "-b",
    :desc => "Set a default branch other than master (valid only with --git)"
  def add
    repo = get_repo_handle

    case
    when options.has_key?("git")
      branch = "master"
      branch = options["branch"] if options.has_key? "branch"

      Dr::GitPackage::setup repo, options["git"], branch
    when options.has_key?("deb")
      Dr::DebPackage::setup repo, options["deb"], options["force"]
    else
      raise ArgumentError, "Either --git or --deb must be specified"
    end
  end


  desc "build [pkg-name]", "build a package from the sources"
  method_option :branch, :aliases => "-b", :type => :string,
                :desc => "build from a different branch"
  method_option :push, :aliases => "-p", :type => :string,
                :desc => "push to suite immediately after building"
  method_option :force, :aliases => "-f", :type => :boolean,
                :desc => "force build even when no changes have been made"
  def build(pkg_name)
    repo = get_repo_handle

    force = false
    force = options["force"] if options.has_key? "force"

    branch = nil
    branch = options["branch"] if options.has_key? "branch"

    pkg = repo.get_package pkg_name
    version = pkg.build branch, force

    unless version
      log :warn, "Build stopped (add -f to build anyway)"
      return
    end

    if options["push"] && version
      if options["push"] == "push"
        repo.push pkg.name, version, "testing" # FIXME: should be configurable
      else
        repo.push pkg.name, version, options["push"]
      end
    end
  end


  desc "push [pkg-name]", "push a built package to a specified suite"
  method_option :suite, :aliases => "-s", :type => :string,
                :desc => "the target suite (defaults to testing)"
  method_option :version, :aliases => "-v", :type => :string,
                :desc => "which version to push (defaults to the highest one build)"
  method_option :force, :aliases => "-f", :type => :boolean,
                :desc => "force inclusion of the package to the suite"
  def push(pkg_name)
    repo = get_repo_handle

    suite = nil
    suite = options["suite"] if options.has_key? "suite"

    version = nil
    version = options["version"] if options.has_key? "version"

    repo.push pkg_name, version, suite, options["force"] == true
  end


  desc "unpush [pkg-name] [suite]", "remove a built package from a suite"
  def unpush(pkg_name, suite)
    repo = get_repo_handle
    repo.unpush pkg_name, suite
  end


  desc "list SUBCOMMAND [ARGS]", "show information about packages"
  map "l" => :list, "ls" => :list
  subcommand "list", List

  desc "rm [pkg-name]", "remove a package completely from the build system"
  method_option :force, :aliases => "-f", :type => :boolean,
                :desc => "force removal even if the package is still used"
  def rm(pkg_name)
    repo = get_repo_handle
    repo.remove pkg_name, options["force"] == true
  end


  desc "rmbuild [pkg-name] [version]", "remove a built version of a package"
  method_option :force, :aliases => "-f", :type => :boolean,
                :desc => "force removal even if the build is still used"
  def rmbuild(pkg_name, version)
    repo = get_repo_handle
    repo.remove_build pkg_name, version, options["force"] == true
  end

  desc "update", "Update and rebuild (if necessary) all the packages in the suite"
  def update(suite="testing")
    log :info, "Updating all packages in the #{suite.fg "blue"} suite"
    repo = get_repo_handle

    updated = 0
    repo.list_packages(suite).each do |pkg|
      log :info, "Updating #{pkg.name.style "pkg-name"}"
      begin
        version = pkg.build
      rescue Dr::Package::UnableToBuild
        log :info, ""
        next
      rescue Exception => e
        # Handle all other exceptions and try to build next package
        log :err, e.to_s
        log :info, ""
        next
      end

      if version && !repo.suite_has_higher_pkg_version?(suite, pkg, version)
        repo.push pkg.name, version, suite
        updated += 1
      end

      log :info, ""
    end

    log :info, "Updated #{updated.to_s.fg "blue"} packages in #{suite.fg "blue"}"
  end


  desc "git-tag-release", "Mark relased packages' repositories"
  method_option :force, :aliases => "-f", :type => :boolean,
                :desc => "Force override existing tags"
  method_option :package, :aliases => "-p", :type => :string,
                :desc => "Only tag a single package"
  method_option :summary, :aliases => "-s", :type => :string,
                :desc => "A summary for the release (Github only)"
  method_option :title, :aliases => "-t", :type => :string,
                :desc => "A title for the release (Github only)"
  def git_tag_release(tag)
    repo = get_repo_handle

    packages = if options["package"] == nil
      repo.list_packages "stable"
    else
      if repo.get_subpackage_versions(options["package"])["stable"].empty?
        log :warn, "This package isn't in the #{"stable".fg "green"} branch, skipping."
      end

      [repo.get_package(options["package"])]
    end

    packages.each do |pkg|
      if pkg.is_a? Dr::GitPackage
        version = repo.get_subpackage_versions(pkg.name)["stable"].values.max
        bm = repo.get_build_metadata pkg.name, version

        pkg.tag_release tag, bm["revision"], options
      else
        log :info, "#{pkg.name.style "pkg-name"} is not associated with a git repo, skipping"
      end
    end
  end


  desc "release", "Push all the packages from testing to release"
  method_option :force, :aliases => "-f", :type => :boolean,
                :desc => "Force-push all released packages"
  def release
    repo = get_repo_handle

    log :info, "Releasing all packages from testing"
    repo.list_packages("testing").each do |pkg|
      v = repo.get_subpackage_versions(pkg.name)["testing"].values
      begin
        repo.push pkg.name, v.max, "stable", (options["force"] == true)
      rescue Dr::AlreadyExists
        ;
      end
    end

    log :info, "Removing packages that are not in testing any more"
    repo.list_packages("release").each do |pkg|
      if ! repo.suite_has_package? "testing", pkg.name
        repo.unpush pkg.name, "release"
      end
    end
  end


  desc "force-sync", "Force cloning the sources repository from scratch again"
  def force_sync(pkg_name)
    repo = get_repo_handle
    pkg = repo.get_package pkg_name

    if pkg.is_a? Dr::GitPackage
      pkg.reinitialise_repo
    else
      raise "The source of #{pkg_name.style "pkg-name"} is not managed by " +
            "#{"dr".bright}"
    end
  end

  desc "snapshot", "save a snapshot of the archive"
  def snapshot(tag)
    repo = get_repo_handle

    log :info, "Releasing all packages from testing"
    repo.list_packages.each do |pkg|
      repo.push pkg.name, nil, "stable"
    end
  end
end


begin
  Dr::check_dependencies [
    "git", "reprepro", "gzip", "debuild", "debootstrap", "qemu-*-static",
    "chroot", "curl", "gpg", "tar", "dpkg", "dpkg-deb", "dpkg-sig", "rm",
    "sudo"
  ]

  RepoCLI.start ARGV
rescue StandardError => e
  Dr::Logger.log :err, e.to_s
end
